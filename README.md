# ChatApp
This is full MERN stack chat App. This App uses Express for the Back-end, MongoDB for Database &amp; React for front-End

# Front End
FrontEnd
    created the App using vite

# BackEnd
BackEnd
    Installed:
        - express - For the backend Server
        - nodemon   - For continous reload and development
        - mongoose - For Data Base
        - socket.io - For Dynamic messages
        - bcrypt - For Password Encryption
        - cookie-parse - For parsing cookies.
        - dotenc - For accessing environment variables
        - jsonweboken - For creating jwt token    


    - Created Routes folder to store all the routes in it. The routes are implemented using express.Router.
    - Also, for good quality and clean code, create controllers to handle the routes neatly.

    Note : First we were using "require" to include the modules but now we are using 'import' and to do so,
    we need to change the 'type' in package.json file to 'module'.

    Note: Also we need to import the js file(that we have created) by using the full name along with extension. If exts are not
    included we get and error.


# Database
    - For this Application, we are using MongoDB as the Database.
    - To start with MongoDB,
        - goto the MongoDB.com
        - create Account
        - create a project
        - copy the password while creating the project
        - copy the mongoDB_URI and paste it into the .env file (also replace the <password> with the actual 
            password)
        - create an async function calling mongoose.connect() with the MONGO_DB_URI as agrs.
    If there are no error, it will be connected to the Database.

    - For the Data to be stored in DB, we need to create Models of the data.
    - For creating a model, we first create a schema using mongoose.Schema(), and then we create a model
    from that schema using mongoose.model("name", <Schema>).

    -User Model
        - fulname
        - username
        - password
        - gender
        - profilePic

    Note: To get the {fullname, username, pass,etc} from the req.body, we need to use a middleware -> express.json()

    Sign Up Complete flow:
        - user fills the form and sends a post request with all the fields
        - get the values for username pass, etc from the req.body (note: for this we need to use express.json() middleware)
        - check if the pass and confirm pass are same
        - check if the user already exists
        - encrypt/Hash the password(using a brcypt)
        - put a profile pic 
            https://avatar.iran.liara.run/public/girl?username=[value] - this url gives us radom profilepics depending on the username and girl/boy
        - save the user to database

    Note : All the variable name should match the model

    Ecrypting the Password:
        - we use brcypt to hash the pass
        - first create a salt using brcypt.genSalt(10);
        - then hash the pass, brcypt(pass, salt) 

    
# JWT
    JWT - JSON Web Token
    JWT is imported from the jsonwebtoken library in express js
    We need to create a token and to do so, we need to call the jwt.sign(), which takes the following args:
        1. payload - here we will pass the userID for our app
        2. secret_key - it will be used to sign the token, its will be stored in the .env file
        3. options: inlcudes various options such as expiresIn, etc.

    once the  token is created, we set it as a cookie in the response using:
        res.cookie("jwt",token, { maxAge : ..})
        here the 1st arg is the name of the cookie ad second is the token and third is the options which inlcudes maxAge and other options


# Login

    login flow :  We need to send the userName and password to the API using post methos. After receiving the userNmae and password, we call the findOne({userName}) to see if there is any such user present.
    Note : we do User.findOne(), where User is the Model

    if we get the user, we compare the password using brcypt.compare(), where 1st arg is the entered password and 2nd is the hashed password(received from the database).

    if both matches, we generate and set the 'jwt'(using the earlier method) in the cookie and send back the response.

# Logout

    logout is simeple - in this API, we just clear the token by setting it to empty and maxAge to 0 followed by sending the response


# Designing the chat APP
    Our Chat will have 2 models :
        1. Message :
            fields :
                - id - automatically generated by mongoDB
                - sender_id 
                - receiver_id - we can make it an array in future to support group msgs
                - message - the actual msg

        2. Conversation :
            fileds:
                - id - automatically generated by mongoDB
                - participants [] - array contains ids of all the participants
                - message [] - array containing the id of all the messages in the conversation.

    
    Note: When we create the any schema say messageSchema, we put sender_id as one of the fields. Now the sender_id is going to be a type of id. we can say:
    type: mongoose.Schema.Types.ObjectId,
    ref : "User",
    here, ObjectId is a special type that say that it is a refernce id from the 'User' Model

    Note: when using mongoose.Schema() to create a  schema, we can put {timestamp : true} as the 2nd arg, it will say that whenever the data is create, it will automatically created the timestamp of the data i.e, when the data was created and updated.


# Messaging Routes

    Send Message:
        we create an API using post method, in which we will be getting id and message from the req.param & req.body.
        Then the sender ID is also need. For this we will create a middleware called proctedRoute, which is authorize and put the user's id in the req.

        In the protectedRoute,
        we get the token from the req.cookie.
        But we wont be able to get the req.cookie.jwt normally. For this, we use cookie-parse. So we import and use the cookie-parse middleware before any routes in the server.js file.
        After getting the token, we verify it, using jwt.verify(token, secret_key).
        the verify method returns the payload, in our case its the sender's user_id.

        Now, get the user from the database using the user_id. add that  user to the req, so that the next middleware/route can access the user(sender)'s details.
        So, If any API is having a protected route as middleware, it will get authenticated and also the authorized user's data will also get attched to the req.

        Now, comming to the sendMessage endpoint. after the protectedRoute middleware is successfully gone through, we get the sender's details in the req.
        get the Conversation from the database by finding the conversations where the participants list contains the sender as well as the receiver Ids.

        If we dont get any conversations i.e, the users are talking for the first time, we create a new Conversation using:
            await Conversation.create({ participants : [reciver_id, sender_id]})
        if you see, the create function creates a collection in the databse and we populate the participants list with the sender as well as the receiver IDs.
        Note: when we create a new conversation, the a default empty message [] is created.

        After the converataion in craeted/get, we create a new message and push this newMessage's id in the conversation.messages array.
        After this, both conversation and newMessage are saved in the database using .save() function.

        We can optimize the save by using promise:
            await Promise.add(conversation.save(), newMessage.save())
            the above code will run in parallel, both the save() will run in parallel. but in the previous case, one will start after the other is finished in the backhround.  

    GET Messages

        To get the messages, we get the sender and the receiver ID.
        Then we get the conversation between them.
        Note: await Conversation.findOne({
            participants: { $all: [sender_id, receiver_id] },
        })
        note: how we selected all the conversation where the participants include sender_id and receiver_id

        In Mongoose, the populate() method is used to automatically replace specified paths in a document with document(s) from other collection(s). It's a powerful feature that allows you to perform "joins" between collections in MongoDB.

        After getting all the messages, we simply selected the message from them or do things according to our requirements.

    GET USERS
        To get all the users in the database, we first use the protectedoute to authorize the user and then get its user id.
        then we get all the users from the database except for the current user using the following:
        await User.find({ _id: { $ne: logged_user } });
        Note: $ne ->  not equal


Now we will focus on the Front-End
# Front End
    For front end, we will use React. For the CSS, we are going to use tailwindCSS & daisyUI

    First we create all the Basic components such as Home, Login, SignUp

    Now that all the pages are created, we start with the integration of the back-end with the front-end.
    We first start with completing the sign-up functionality. 
    
    For this we install react-router-dom. To use the router throughout our app, we encapsulate the whole app by <BrowserRouter> given by the react-router-dom as:
        <BrowserRouter>
             <App />
        </BrowserRouter>

    After this, for routing to different url, we use <Routes> component which is wrapped around each <Route path='/' element= {<Home />} />
    eg:
    <Routes>
        <Route path="/" element= {<Home />} />
    </Routes>

    We also replaces <a> with <Link> which is given by react-router-dom 

# Integration
    Now we will start with the main logic for integration:
    To get/set the input, we create a state as "inputs" and "setInputs" using useState, that will contain fullName, userName, password, confirmPassword, gender and the default value for this will be "".
    After this, we have the input labels in the singUp component, where value of the input will come from the "inputs" state and also we will attach a onChange event listener to set the value of inputs as below:
        value={inputs.fullName}
              onChange={(e) =>
                setInputs({ ...inputs, fullName: e.target.value })
              }
    
    After doing the same for all the inputs, we create a function to handle the submisstion of the form named as "handleSubmit"
    Note: we prevent the default behaviour on submit of the form as on submitting the form, it refreshes the page. and then we are logging the input to the console to check if everything is working fine. In future, we will remove the log and send the input to the backend.

    Also we are setting all the inputs but same is not the case with gender, because we are made a Gender component. Now for its input, we create a funtion responsible for changing the gender in the  inputs and pass that function to the gender component as props so that we can set the state in the parent component(signUp) throught the Child(Gender) component.
    function name : handleGenderChange
    refer the code for changes

    Now we will use the data entered to sign up or register our user. We can write the code there itseld but it will make our code very long and complex and also very hard to read. So we will create hooks to signup our user to modularize our code.
    we create a hook as 'useSignup' that will return a signup function that takens in all the inputs validate it and throws errors accordingly and also signs up the user.

    Also for showing all the errors, we use a library - hot-toast, that show all the errors at the top on the App. To install we need to npm i react-hot-toast.
    Then we need to add the <Toast /> component to our App.js at the begining. Now to consume it, we just use - toast.error("error message").

    Notice: we are handling the error both at the client side as well as the Server side. In the signUp method, we validate all the fields are filled and passwords & confirmedpas matches, etc. But its important to note that the validation at the server-side is more important, because the client-side code can be cheated easily but same is not possible for server-side validation.

    we pass all the inputs to our signUp function, which will post request to our backend.
    For this, we fetch() at the api created by us for sign up with all the  inputs required.
    we need to pass the method, the url and the inputs and also the headers.
    note: the call should be awaited. also we need to stringyfy the json before sending. 
    now we get the response and we do res.json() to convert it to json and log it to the console. 
    Now if we try to run the App and sign up, we will get a CORS error, and this error is beacuse we are using two different domain for the frontend and back end. We will only get this error in Development and not in production beause, in production we will be using the same doamin for both backend and front end.
    To solve this error, proxy field in the vite.config as :
         proxy : {
            "/api" :{
                target : "http://localhost:5000"
            } 

    After this we need to restart both frontend as well as our backend and also need to change the link from :
         await fetch("http://localhost:5000/api/suth/signup")
                 to
         await fetch("/api/suth/signup")

    Now we will create the Authcontex. After signing up the users, we want to store the user to the  local storage(jwt). with this we dont need to login the user everytime we go to the home page or some other page. The details will be fetched from the local storage and will be used to authorize. We will use context to access the userdata stored in the local.

    after signing up, we store the user to local and also to the context.
    For this, we create a file AuthContext which will use the createContext from react to create a Context.  Also we will create a AuthCOntextProvider that will provide the data(userdata from local that was stored earllier) to the Children. 
    Then we wrap our App in the AuthContextProvider.
    also we create a hook useAuthContext that will give us the AuthContext & the SetAuthContext. We use the useAuthContext to set the authUser

    Now in our App.js, we get the authUser and for the signup route if its present we show the Home Page else we go to the Signup Page.
    Same we will do for other pages as well.For login, If the user is present, to the home else to login. For Home -> if user goto home else to login


     
# Log Out
    For the logout functionality, we will create a hook "useLogout" which will have state loading as others. we will do a fetch call at backend for the "/logout" route. if we get proper response(if there is no error), we remove the userdata from the local storage and update the context value using useAuthContext.
    Now in the LogoutButton Component, we get the logout function using the useLogout hook and on click of the logout button we add that function.
    We can also add the loading state as other pages.


# Log in
    The Login is also going to be same as other. For this also we create a hook which will be responsible for loggin the user in. refer to the code changes for the same

# Sidbar - getting the conversations
    For this we will be using 'zustand' which helps us to manage global state(same as context or redux). To install zustand do npm i zustand.
    After that we create a folder like store to store all the global state variables.
    we create a file call useConversation to store our global state like conversations and message. 

    we use the create() given by zustand takes in set() as an args and we define states and its setStates as:
        const useConversation = create((set) => ({
            selectedConverstaion: null,
            setSelctedConversation: (selectedConversation) =>
                set({ selectedConversation }),
            messages: [],
            setMessage: (messages) => set({ messages }),
        }));

    Now we already have an api at the backend to get all the conversation(for sidebar) as '/api/users'.
    We create a hooke called useGetConversations which will fetch the conversations using the above api and return those to the SideBar Component.

    Now, we have all the conversations in the <Conversations /> using the useGetConversations hook. To show the conversations(users) in the sideBar, we need to modify the <Conversation />. We map over the conversations and pass the converastion to each of the <Conversation> and fill the details accordingly in that component.
    Note : we also pass a boolean value of lastIndex to know which conversation is the last one and accordingly we hide the divider for the last conversation(plz refer to the code). 

    Now if the user clicks on an user in the sidebar, that user should get highlighted. To do so, we will use "zustand". It is used to create a global store from which all the components can access the variables. It is like useContext or Redux but easier. To create a store, we create a folder called store or 'zustand'. Now create a file called useConversation.js, that will use the create method from zustand and create the global variables and its setter function. Now import and use the global variables where ever neccessary.
    For the Conversation selection, we use the useConversation to get the selectedConversation and setSelectedConversation method. Now, if the current conversation components' id and the selectedConversations' id is same put isSelected to true. Based on the same boolean flag, set the background color of the conversation to back. also attach an onClick event handler to the covnersation where if any user click on the component, it set the selectedConversation to that user.


# Message Window
    We need to show chat of the selected user. To do so, we again use the zustand to get the selectedConversation and then update the chat window to show the selected user's name.

# Messaging - sending msg
    We create a new hook, useSendMessage that will do a post request to the backend api for sending message to the selected user.
    We call the hook in messageInput Component that will take the input from the input box.

# Messaging - Getting msgs
    To get the message, we again create a hooke called useGetMessages(). this will have a useEffect which will have a function that will call the backend API - "api/message" to get all the message of the selected user. Also we will have a skeleton UI to show while the messages are laoding. plz refer the code.


    Also we need to update the chat-text UI based on whether its sent or received. For sent the messages should appear on the right side of chat window else on the left. 
    To do so, We will create a variable called chatReceived which will be true when the msg is received and false in case we are sending it.

    To populate the chatReceived bool var, we need to get the authUser and selectedConversation from the useAuthContext() and useConversation() respectively. Also depending on the chatReceived flag we update the msg profile pic.


    There's a problem with out chat App, the chat screen doesnot show the current or the most recent chat. We need to show the recent chat. TO do so, we will use the useEffect in the Messages component. Here we will attach a reference to each Message  and will call the scrollToView(). Note : This will not work, we will have to out the scrollToView() in a setTimeOut(). (Still Dont know why. Please find a better way to do so)


# Search Funcionality
    Refer to the code changes for Search Functionality


# Socket IO - Dynamic Messaging

    For this we will use socket.io which helps us notify all the other users. 
    We basically wrap our server around socket. How socket works is that when we send a requrest to server, the server does some work and then socket helps us to send responses to various users. 
    To create a socket server : 
                
        const app = express();
        const server = http.createServer(app);
        const io = new Server(server, {
        cors: {
            origin: ["http://localhost:3000"],
            methods: ["GET", "POST"],
        },
        });
    now the io can be used to emit events. So, when a user login is, a connection event is emiited which contains a socket i.e, the information of the client that just got connected to.
    Now when ever a user is connected, we store the userId and emit an event notifying all the users about the new connection. This way other user can come to know that a new user has just come online.

    Same thing can be done in case of logout to let the other users know that the user has logged out and when can show that user offline.


    For Real-Time messaging, whenever we send a message, we will emit a newMessage event to the receiver. Also we will create a new hook that take the new message and add it to the messages in the zustand store. This is automatically update the chats

    Now we will shake the new message. So if we get a new message we will add css to shake or vibrate the message. Refer to the CSS for this.

    Now we add a notification sound when we get new messages. Refer the code.
    Note: in usEffect we cleant he socket.off(newMessage) event, if we dont do so then we might run into problems like we might hear notification sound as many times as there are users

# Deployement
    
    Root path of the App is required first. To get the root path, we do path.resolve(). Now at the last of our routes in server.js we need to use a middleware which will help to serve static pages or images of anything. we will use this middleware to serve our frontEnd as :  
            app.use(express.static(path.join(__dirname, "/FrontEnd/dist")));
        Here dist does not actually exist now, when we run the build command, the build will be put in dist folder.
    Also we will add a wildCard route at the end that will serve the frontEnd Page whenver a route other than the previous is visited.

    With the above we will be able to run our frontEnd from the server as well.

    Once the build ready in the dist folder, all we need to do is push the changes to git and use Render to deploy it.

    To Deploy the app, go to Render -> New -> Web Service -> Build and deplot from Git Repo ->  authorize git -> select the Repo -> provide the details as necessary -> Also Add the environment Vairables -> create Web Service.

    After this the App should be deployed!
    Note : Real-Time Live Status or Messaging wont be working now because we in the io that we created we were the localhost link to create it but now we need to use the deploye linke to create the io.
    Refer the commit changes for the code. Once that is done it should support the real-time messaging as well.